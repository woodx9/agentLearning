# Tool Call API Learning Guide

[中文版本](./README_zh.md)

This chapter introduces two different tool calling approaches: Native Function Call and XML Tool Call.

## Table of Contents
- [Overview](#overview)
- [Native Function Call](#native-function-call)
- [XML Tool Call](#xml-tool-call)
- [Comparison](#comparison)
- [Usage Recommendations](#usage-recommendations)
- [References](#references)

## Overview

When interacting with large language models, we often need the model to call external tools to retrieve real-time data or perform specific operations. There are currently two main implementation approaches:

1. **Native Function Call**: Using OpenAI's standard function calling interface
2. **XML Tool Call**: Embedding tool calls in natural language through XML format

## Native Function Call

### Core Features
- Uses standardized JSON Schema to define tool interfaces
- Model returns structured tool call requests
- Supports multi-turn conversations and tool chaining
- More standardized and reliable

### Implementation Flow

![Native Function Call Flow](./images/native_function_call.png)

### Key Code Structure

**1. Tool Definition**
```python
tools = [
  {
    "type": "function",
    "function": {
      "name": "search_gutenberg_books",
      "description": "Search for books in the Project Gutenberg library",
      "parameters": {
        "type": "object",
        "properties": {
          "search_terms": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of search terms to find books"
          }
        },
        "required": ["search_terms"]
      }
    }
  }
]
```

**2. Tool Call Handling**
```python
# Handle tool calls returned by the model
for tool_call in response.tool_calls:
    args = json.loads(tool_call.function.arguments)
    tool_result = search_gutenberg_books(**args)
    messages.append({
        "role": "tool",
        "tool_call_id": tool_call.id,
        "name": tool_call.function.name,
        "content": json.dumps(tool_result)
    })
```

### Advantages
- High degree of structure, easy to validate and debug
- Supports complex parameter type definitions
- Better error handling
- Strong tool call traceability

### Disadvantages
- Must strictly follow OpenAI's interface specifications
- Cannot be used with models that don't support function calling
- Relatively complex implementation

## XML Tool Call

### Core Features
- Embeds XML-formatted tool calls in natural language responses
- More flexible, not dependent on specific API interfaces
- Can be combined with explanatory text
- Works with any text generation model

### Implementation Flow

![XML Tool Call Flow](./images/xml_tool_call.png)

### Key Code Structure

**1. Prompt Design**
```python
prompt = """
When you decide to call a tool, output in this format:

[Some natural language explanation for the user]
<search_gutenberg_books>
  <search_terms>term1</search_terms>
  <search_terms>term2</search_terms>
  ...
</search_gutenberg_books>

Rules:
1. The <search_gutenberg_books> block must be valid XML.
2. The explanation can be any helpful text for the user, but outside the XML tags.
3. Keep XML block on separate lines, do not nest other tags inside.
"""
```

**2. XML Parsing**
```python
# Extract XML content using regex
xml_match = re.search(r"<search_gutenberg_books>[\s\S]*?</search_gutenberg_books>", model_text)
xml_str = xml_match.group(0)

# Parse XML parameters
root = ET.fromstring(xml_str)
search_terms = [elem.text for elem in root.findall("search_terms")]
```

### Advantages
- Simple implementation, not dependent on specific APIs
- Can seamlessly combine with natural language explanations
- Works with any text generation model
- More intuitive and readable

### Disadvantages
- Relies on regex parsing, may not be robust enough
- Lacks strict type checking
- Relatively simple error handling
- XML format may be incorrectly generated by the model

## Comparison

| Feature | Native Function Call | XML Tool Call |
|---------|---------------------|---------------|
| **Implementation Complexity** | Medium | Simple |
| **Model Compatibility** | Only models supporting function calling | All text generation models |
| **Type Safety** | High (JSON Schema validation) | Low (manual validation required) |
| **Error Handling** | Comprehensive | Basic |
| **Readability** | Structured | More intuitive |
| **Flexibility** | Limited by API specifications | Highly flexible |
| **Debugging Difficulty** | Easy | Medium |

## Usage Recommendations

### Choose Native Function Call when:
- Using models that support function calling (e.g., GPT-4, Claude 3.5)
- Need strict parameter validation and type checking
- Building production-grade applications with high reliability requirements
- Need complex tool chaining

### Choose XML Tool Call when:
- Using models that don't support function calling
- Need rapid prototyping
- Want tool calls combined with natural language explanations
- Have implementation complexity constraints

## Practical Application Examples

The choice between these approaches mainly depends on your specific needs, model support situation, and technical stack constraints. Before choosing a tool calling method, you need to implement based on model evaluation results to determine which tool calling approach has a higher success rate.

## References

[Claude Function Calling](https://docs.anthropic.com/en/docs/agents-and-tools/tool-use/overview)
